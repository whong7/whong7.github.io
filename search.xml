<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[策略模式]]></title>
      <url>%2F2016%2F10%2F27%2F1.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[策略模式定义了算法族，分别封装起来，让他们之间可以相互代替，此模式让算法的变化独立于使用算法的客户 策略模式核心是对算法的封装 专注于实现算法（策略）的选择，支持运行时动态改变策略 具体实现是把变化的部分找出来，定义为接口，每个接口对应一组算法，每一个都是一种策略 同一接口下的算法是可以相互替换的 算法是独立于客户代码的，也就是对算法封装的具体体现 使用情形 父类中的 部分 方法，会因 子类 的实现而有区别，单纯的继承并不能很好的解决问题，会导致需求修改时：父类和子类都需要修改。 做法：抽象超类中，会变化的部分取出并“封装”起来，好让其他部分不会受到影响。 结果：代码变化引起的不经意后果变少，系统变得更有弹性。 设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起，以便以后可以轻易的改动或拓展此部分，而不影响不需要变化的其他部分 针对接口编程，而不是针对实现编程：将行为通过接口实现，而不是绑定到父类中 多用组合，少用继承 示例问题现有100种Duck，叫声、飞行都是不同的。于是我们定义了100个类来表示100种不同类型的Duck。我们发现Duck问题中最难处理的部分就是fly、quack这两个行为，一旦发生变化我们就需要修改具体Duck类，甚至是Duck基类，不仅需要花费大量的时间，而且所有具体Duck类中都实现了fly与quack方法，显得很臃肿。还有最重要的问题，我们无法动态地修改Duck的行为，比如小Duck游得慢叫声小，长大后游得快叫声大，也无法应对行为变化问题。。。。这一系列的问题想向我们说明一点：这从一开始就是一个糟糕的设计。 如何应用策略模式？策略模式要求把变化的部分封装起来，首先，我们要找到代码中频频发生变化的部分在上一个例子中，变化的部分是什么？1.fly行为2.quack行为3.其它可能存在的行为…下面我们把这些行为封装起来 将行为封装起来fly行为 1234567891011121314151617181920212223242526import UIKitclass FlyBehavior: NSObject &#123; func fly()&#123; &#125; &#125;class FlyWithWings: FlyBehavior &#123; override func fly() &#123; print("I'm flying") &#125; &#125;class FlyNoWay: FlyBehavior &#123; override func fly() &#123; print("I can't fly") &#125;&#125; quack行为 123456789101112131415161718192021222324252627282930313233import UIKitclass QuackBehavior: NSObject &#123; func quack()&#123; &#125; &#125;class Quack: QuackBehavior &#123; override func quack() &#123; print("Quack") &#125; &#125;class MuteQuack: QuackBehavior &#123; override func quack() &#123; print("Slience") &#125; &#125;class Squeak: QuackBehavior &#123; override func quack() &#123; print("Squeak") &#125; &#125; 封装好“变化”之后，我们的Duck基类也要做相应改变：1234567891011121314151617181920import UIKitclass Duck: NSObject &#123; var flybehavior: FlyBehavior? var quackBehavior: QuackBehavior? func performFly() &#123; flybehavior?.fly() &#125; func performQuack()&#123; quackBehavior?.quack() &#125; func swim()&#123; print("swiming") &#125;&#125; 现在来看看我们新的具体Duck类123456789class MallardDuck: Duck &#123; override init() &#123; super.init() flybehavior = FlyWithWings() quackBehavior = Quack() &#125; &#125; 效果示例123456789101112131415161718192021222324252627282930import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() //test let mallard:Duck = MallardDuck() mallard.performQuack() mallard.performFly() //模型可以动态的改变飞行行为，如果把行为的实现绑死在鸭子勒种，无法做到这样 mallard.flybehavior = FlyNoWay() mallard.performFly() &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125;输出结果：QuackI'm flyingI can't fly demo下载 思维导图解析 思维导图下载 总结策略模式的核心是要把频繁发生变化的部分封装起来，作用是把变化部分的影响隔离开，避免局部的变化对其它fixed部分造成影响，设计时可能需要更多的时间，但便于维护、复用与扩展，在本例中，Fly、Quack行为都可以在新的类（如Pig）中复用；一旦行为发生变化我们只需要修改各个行为接口，最多再对Duck基类做简单修改就可以从容地应对变化了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>%2F2016%2F10%2F25%2F0.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[什么是设计模式？ 自问：设计模式是什么？ 自答：设计模式是由代码结构优化经验萃取出来的理论知识，应用成熟的设计模式能够增强代码的可复用性、可扩展性与可维护性。 自问：你好像很专业的样子，那好，既然设计模式有这么多好处，那是不是应用了设计模式的设计都是好设计？ 自答：当然不是，我们不能为了使用模式而使用模式。设计模式可不能滥用，毕竟应用设计模式必须要作出一些牺牲（比如增加类结构的复杂性…），所以滥用设计模式的话是会出事的。而且，就算我们有了锤子，也不能把所有问题都看作钉子吧？ 要不要使用设计模式？ 这是个值得思考的问题，毕竟现在我们已经拥有了一把锤子，要不要用它当然成了问题，毕竟不是所有的问题都可以用锤子来解决。退一步讲，即便所有问题都能用锤子解决，我们也不确定使用锤子是不是最好的解决方案（拔钉子的话，可能用钳子更好些…） 当我们拿着某个设计模式想放进我们的代码中时，最好权衡一下利弊，诚然，设计模式具有的设计上的弹性一定会给我们之后的维护变更带来些便利。但是利与弊到底哪个更多一些，我们需要先回答几个问题再做决定： 我们的项目是不是几乎不涉及维护或者没有后续版本，那么我们引入设计模式还有必要吗？ 我们项目的规模是不是大到了不用设计模式不行的地步？ 这个设计模式用在这里合适吗？有没有更合适的？ 非要用设计模式吗？可不可以用几个简单的设计原则来代替？ 引入设计模式之后，代码结构的复杂度大大增加，重构的成本我们可以接受吗？ 如果深思熟虑之后，还是觉得使用设计模式比较好，那么，放心去用吧，之后好好享受设计模式带来的好处吧 设计原则总结设计原则都是一些简单的指导意见，没有固定的实现，因而设计原则也更加灵活，常见的设计原则如下： 封装变化（把易于发生变化的部分抽出来，以减少其变化对其它部分的影响） 多用组合，少用继承（组合比继承更有弹性） 针对接口编程，不针对实现编程（使用接口可以避免直接依赖具体类） 为交互对象之间的松耦合设计而努力（更松的耦合意味着更多的弹性） 类应该对扩展开放，对修改关闭（open-close原则） 依赖抽象，不要依赖具体类（减少对具体类的直接依赖） 只和朋友交谈（密友原则） 别找我，我会找你（Don’t call me, I will call you back.安卓开发的大原则） 类应该只有一个改变的理由（单一责任原则） 能用设计原则解决的问题就不要用设计模式（杀鸡焉用宰牛刀…），因为设计原则实现起来更加灵活，更加轻巧（不用去考虑模式的条条框框…） 设计模式总结 名称 特点 策略模式（Strategy） 把可以替换的算法步骤封装成一个个算法族，供运行时动态选择 观察者模式（Observer） 定义并维护对象之间的一对多关系 装饰者模式（Decorator） 建立拥有共同超类的装饰者与被装饰者来实现功能的动态扩展 工厂模式（Factory） 封装对象的创建过程，包括工厂方法模式和抽象工厂模式 单件（例）模式（Singleton） 用来创建唯一的对象（比如数据库连接对象，线程池对象等等） 命令模式（Command） 封装方法调用细节，解耦请求者与执行者 适配器模式（Adapter） 用来实现不同接口间的转换 外观模式（Facade） 为复杂的子系统提供简单易用的高层接口 模版方法模式（Template Method） 用来封装算法骨架（流程），某些步骤由子类实现 迭代器模式（Iterator） 用来封装遍历细节 组合模式（Composite） 提供一种层级结构，使得我们能够忽略对象与对象集合间的差异，一视同仁地对待它们 状态模式（State） 把所有动作都封装在状态对象中，状态持有者将行为委托给当前状态对象 代理模式（Proxy） 通过插入第三方（代理对象）来分离调用者和被调用者（不同于执行者） 复合模式（Compound） 复合模式（Compound） 将多个模式组合结合起来形成一个“框架”，以解决一般性问题 桥接模式（Bridge） 将抽象的控制类与具体实现类通过组合解耦，使得抽象层类与实现层类可以对立与对方而变化 生成器模式（Builder） 用来封装组合结构（树形结构）的构造过程，与迭代器模式类似，都隐藏了组合结构的内部实现，只提供一组用于创建组合结构的接口 责任链模式（Chain of Responsibility） 让一个请求可以被一组接收者顺序处理，类似于Android处理请求的方式：一个接收者捕获请求后可以return true消费掉请求，也可以return false传递给接收者队列中的下一个接收者（观察者） 蝇量模式（Flyweight） 抽象出对象管理层来统一管理大量的同类型对象，以减少运行时对象实例的个数，减少内存消耗 解释器模式（Interpreter） 用来为简单语言创建解释器，将语法规则直接映射为各个类，结构简单，但效率较低 中介者模式（Mediator） 引入中介者来封装多个对象间的复杂交互，以降低同级（在类结构统一层次上的）对象间的依赖 备忘录模式（Memento） 支持对象状态的保存与恢复，并将对象状态数据封装起来，独立于客户代码以提供保护（Java中可以结合序列化反序列化技术来实现该模式） 原型模式（Prototype） 以现有的对象为原型，通过clone得到新的对象（以简化新对象的创建过程） 访问者模式（Visitor） 为组合结构添加新的操作，而不需要频繁的改变组合结构 面向对象的设计（Object Oriented Design）一直伴随着OOD的问题就是“折衷”（或者说是“取舍”），最简单的例子——要不要用设计模式？ 用，意味着将产生复杂的类关系，多层的抽象，我们将牺牲易读性换取易扩展性、易维护性或者其它特性 不用，意味着我们不需要对现有代码进行重构（或者不用去在复杂的设计上耗费过多的时间），但使用设计模式的所有好处我们就都享受不到了 二者选其一，这就是一个“取舍”，或者创造第三个选项（比如使用设计原则），这就是一个“折衷”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS&OC交互（WKWebView）]]></title>
      <url>%2F2016%2F10%2F24%2FJS%26OC%E4%BA%A4%E4%BA%92%EF%BC%88WKWebView%EF%BC%89%2F</url>
      <content type="text"><![CDATA[oc调用js UIwebView 使用 WKWebView 取代。优化了js交互代理方法，并且开元，完善了UIwebView 的内存泄漏问题，大幅度减小了内存；UIWebView自iOS2就有，WKWebView从iOS8才有，毫无疑问WKWebView将逐步取代笨重的UIWebView。下面列举一些其它的优势： 更多的支持HTML5的特性 官方宣称的高达60fps的滚动刷新率以及内置手势 Safari相同的JavaScript引擎 将UIWebViewDelegate与UIWebView拆分成了14类与3个协议(官方文档说明) 另外用的比较多的，增加加载进度属性：estimatedProgress 代码展示代码作用：取到网络上点击图片的地址，并返回图片的位置信息（详见动图展示） OC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#import "ViewController.h"@import WebKit;@interface ViewController ()&lt;WKNavigationDelegate,WKUIDelegate,UIGestureRecognizerDelegate&gt;@property (nonatomic)WKWebView *webView;@end@implementation ViewController- (WKWebView *)webView &#123; if (_webView == nil) &#123; _webView = [[WKWebView alloc] initWithFrame:self.view.bounds]; _webView.navigationDelegate = self; //拦截信息 _webView.UIDelegate = self; //添加点击手势 需解决拦截棒 UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapWebView:)]; [_webView addGestureRecognizer:tap]; tap.delegate = self; [_webView addGestureRecognizer:tap]; &#125; return _webView;&#125;-(void)tapWebView:(UITapGestureRecognizer *)gesture&#123; NSLog(@"%@",gesture); CGPoint point = [gesture locationInView:self.webView]; NSString *js = [NSString stringWithFormat:@"wh_imageAourceFromPoint(%g,%g)",point.x,point.y]; [self checkJsWithCompletion:^&#123; //执行js [self.webView evaluateJavaScript:js completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; NSLog(@"====&gt;%@",result); &#125;]; &#125;]; &#125;- (void)viewDidLoad &#123; [super viewDidLoad]; [self.view addSubview:self.webView]; NSURL *url = [NSURL URLWithString:@"http://image.baidu.com"]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; [self.webView loadRequest:request]; &#125;#pragma mark - WKUIDelegate//拦截 js 中的 alert- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123; NSLog(@"%@",message); completionHandler();&#125;//允许多个手势并发#pragma mark - UIGestureRecognizerDelegate-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; return YES;&#125;#pragma mark - webview 代理方法//截取网络访问请求-(void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123; NSLog(@"%@",navigationAction.request); //决定对请求的处理 decisionHandler(WKNavigationActionPolicyAllow);&#125;//完成导航-(void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation&#123; //注入 js NSLog(@"%@",[self jsString]); [webView evaluateJavaScript:[self jsString] completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; NSLog(@"%@",result); [self checkJsWithCompletion:^&#123; NSLog(@"js 注入成功"); &#125;]; &#125;];&#125;//检验注入是否完成,获取js完成后续操作- (void)checkJsWithCompletion:(void(^)())completion&#123; NSString *js = @"typeof wh_imageAourceFromPoint;"; [self.webView evaluateJavaScript:js completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; NSLog(@"%@",result); if (error != nil) &#123; NSLog(@"error"); return ; &#125; // 执行完成回调 completion(); &#125;]; &#125;-(void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation&#123; &#125;- (NSString *)jsString &#123; NSURL *url = [[NSBundle mainBundle] URLForResource:@"tools.js" withExtension:nil]; return [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:NULL];&#125;@end js代码：tools.js 12345678910111213141516function wh_imageAourceFromPoint(x,y)&#123; var element = document.elementFromPoint(x,y); if(element.tagName == 'IMG' &amp;&amp; element.src)&#123; var rect = element.getBoundingClientRect(); alert(rect.top + '|' + rect.left + '|' + rect.right + '|' +rect.height); return element.src; &#125; return null; &#125;function wh_hello() &#123; return "hello world";&#125; 运行效果 demo下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SizeClass(Xcode8)]]></title>
      <url>%2F2016%2F08%2F27%2FsizeClass%2F</url>
      <content type="text"><![CDATA[SizeClass storyboard编辑 Size Class最大的帮助是,解决横屏适配和iPhone iPad共享一个设计板 plus系列: 竖屏: CR 横屏:RC / 非plus系统: 竖屏CR 横屏CC xcode 8 SizeClass 竖屏 设定如下图 xcode 8 SizeClass 横屏 设定如下图 plus系统需要选择RC 非plus系统需要选择CC 运行结果如下，虚拟器 6s 代码监听旋转方向123456789101112131415161718192021//previousTraitCollection: 转动之前的SizeClass- (void)traitCollectionDidChange:(UITraitCollection *)previousTraitCollection&#123; //NSLog(@"previousTraitCollection: %@", previousTraitCollection); //代码获取当前方法的SizeCalss变化 --&gt; 目前的6S 高度会有R--&gt;C的变化 UIUserInterfaceSizeClass hSizeClass = self.traitCollection.verticalSizeClass; if (hSizeClass == UIUserInterfaceSizeClassCompact) &#123; NSLog(@"横屏"); &#125; else &#123; NSLog(@"竖屏"); &#125; NSLog(@"水平SizeClass: %zd", hSizeClass); //_UITraitNameHorizontalSizeClass: 宽度 --&gt; w C //_UITraitNameVerticalSizeClass: 高度 --&gt; h R /** &lt;UITraitCollection: 0x6100000c78c0; _UITraitNameUserInterfaceIdiom = Phone, _UITraitNameDisplayScale = 2.000000, _UITraitNameDisplayGamut = sRGB, _UITraitNameHorizontalSizeClass = Compact, _UITraitNameVerticalSizeClass = Regular, _UITraitNameTouchLevel = 0, _UITraitNameInteractionModel = 1, _UITraitNameUserInterfaceStyle = 1, _UITraitNameLayoutDirection = 0, _UITraitNameForceTouchCapability = 2, _UITraitNamePreferredContentSizeCategory = UICTContentSizeCategoryL&gt; */&#125; demo下载地址SizeClass.zip]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nav边缘回退手势 替换为 全屏幕回退手势]]></title>
      <url>%2F2016%2F08%2F21%2Fnav%E8%BE%B9%E7%BC%98%E5%9B%9E%E9%80%80%E6%89%8B%E5%8A%BF%20%E6%9B%BF%E6%8D%A2%E4%B8%BA%20%E5%85%A8%E5%B1%8F%E5%B9%95%E5%9B%9E%E9%80%80%E6%89%8B%E5%8A%BF%20%2F</url>
      <content type="text"><![CDATA[在分类中通过方法交换，实现对系统方法的替换，可以实现便捷编程的目的； 将该分类拖拽到项目中，便可将 系统nav的边缘拖拽回退 转化成 全屏幕拖拽回退 方法交换代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//// UINavigationController+WHObjcSugar.m// Created by 吴鸿 on 2016/6/10.// Copyright © 2016年 吴鸿. All rights reserved.//#import "UINavigationController+WHObjcSugar.h"#import &lt;objc/runtime.h&gt;@interface WHFullScreenPopGestureRecognizerDelegate : NSObject &lt;UIGestureRecognizerDelegate&gt;@property (nonatomic, weak) UINavigationController *navigationController;@end@implementation WHFullScreenPopGestureRecognizerDelegate- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)gestureRecognizer &#123; // 判断是否是根控制器，如果是，取消手势 if (self.navigationController.viewControllers.count &lt;= 1) &#123; return NO; &#125; // 如果正在转场动画，取消手势 if ([[self.navigationController valueForKey:@"_isTransitioning"] boolValue]) &#123; return NO; &#125; // 判断手指移动方向 CGPoint translation = [gestureRecognizer translationInView:gestureRecognizer.view]; if (translation.x &lt;= 0) &#123; return NO; &#125; return YES;&#125;@end@implementation UINavigationController (WHObjcSugar)+ (void)load &#123; Method originalMethod = class_getInstanceMethod([self class], @selector(pushViewController:animated:)); Method swizzledMethod = class_getInstanceMethod([self class], @selector(wh_pushViewController:animated:)); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;- (void)wh_pushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; //判断 手势识别器 的view 上面是否含有我们自定义的手势 if (![self.interactivePopGestureRecognizer.view.gestureRecognizers containsObject:self.wh_popGestureRecognizer]) &#123; //如果没有添加 平移手势 [self.interactivePopGestureRecognizer.view addGestureRecognizer:self.wh_popGestureRecognizer]; //为平移手势 添加 监听者 和 执行方法，只替换手势，其他不变。 //1.系统自带的手势是UIScreenEdgePanGestureRecognizer类型对象,屏幕边缘滑动手势 //2.系统自带手势target是_UINavigationInteractiveTransition类型的对象 //3.target调用的action方法名叫handleNavigationTransition: NSArray *targets = [self.interactivePopGestureRecognizer valueForKey:@"targets"]; id internalTarget = [targets.firstObject valueForKey:@"target"]; SEL internalAction = NSSelectorFromString(@"handleNavigationTransition:"); // 什么时候调用：每次触发手势之前都会询问下代理，是否触发。// 作用：拦截手势触发 self.wh_popGestureRecognizer.delegate = [self wh_fullScreenPopGestureRecognizerDelegate]; [self.wh_popGestureRecognizer addTarget:internalTarget action:internalAction]; // 禁用系统的交互手势 self.interactivePopGestureRecognizer.enabled = NO; &#125; //保险起见，如果当前控制器不是 导航控制器的 自控制器，就使用 “系统自带的方法”（交换过的）！ if (![self.viewControllers containsObject:viewController]) &#123; [self wh_pushViewController:viewController animated:animated]; &#125;&#125;- (WHFullScreenPopGestureRecognizerDelegate *)wh_fullScreenPopGestureRecognizerDelegate &#123; //_cmd在Objective-C的方法中表示当前方法的selector，正如同self表示当前方法调用的对象实例(补充在本文最下面)。 WHFullScreenPopGestureRecognizerDelegate *delegate = objc_getAssociatedObject(self, _cmd); if (!delegate) &#123; delegate = [[WHFullScreenPopGestureRecognizerDelegate alloc] init]; delegate.navigationController = self; objc_setAssociatedObject(self, _cmd, delegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return delegate;&#125;- (UIPanGestureRecognizer *)wh_popGestureRecognizer &#123; //使用 动态添加属性 的方法，避免每次重新创建 UIPanGestureRecognizer *panGestureRecognizer = objc_getAssociatedObject(self, _cmd); //如果对象 有这个属性，直接用；没有的话在进行创建 if (panGestureRecognizer == nil) &#123; panGestureRecognizer = [[UIPanGestureRecognizer alloc] init]; panGestureRecognizer.maximumNumberOfTouches = 1; objc_setAssociatedObject(self, _cmd, panGestureRecognizer, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return panGestureRecognizer;&#125;@end//补充 _cmd 用法/* _cmd在Objective-C的方法中表示当前方法的selector，正如同self表示当前方法调用的对象实例。 1、 //比如需要打印当前被调用的方法，可以在一个方法中添加： NSLog(@"%@ call",NSStringFromSelector(_cmd)); 2、 还有一种用法是在runtime的时候，比如在某个分类方法里为对象动态添加属性，由于_cmd是在编译时候(compile-time)就已经确定的值，所以可以直接使用 该用法取自于: forkingdog / UITableView-FDTemplateLayoutCell 中的用法 由于objc_getAssociatedObject 和 objc_setAssociatedObject 第二个参数需要传入一个属性的键名，是 const void * 类型的，通常的做法是 而使用_cmd可以直接使用该@selector的名称，即someCategoryMethod，并且能保证改名称不重复 */ 下载链接分类下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS&OC交互（UIwebView、JSContext）]]></title>
      <url>%2F2016%2F08%2F14%2FJS%26OC%E4%BA%A4%E4%BA%92%EF%BC%88UIwebView%E3%80%81JSContext%EF%BC%89%2F</url>
      <content type="text"><![CDATA[oc调用js代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#import "ViewController.h"#import &lt;JavaScriptCore/JavaScriptCore.h&gt;@interface ViewController ()@property (weak, nonatomic) IBOutlet UIWebView *webView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSString *path = [[NSBundle mainBundle] pathForResource:@"JSContextDemo.html" ofType:nil]; NSURLRequest *request = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:path]]; [_webView loadRequest:request]; #pragma mark - JS调用OC的方法 // 拿到JS的上下文 JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]; /** 1.找到网页分享标签点击时调用的函数名 2.定义好JS要调用的OC的代码块 */ context[@"share"] = ^() &#123; NSLog(@"在这里面实现OC的分享的操作"); &#125;;&#125;#pragma mark - OC调用JS的点击事件- (IBAction)OC_invokJS:(id)sender &#123; // 拿到JS的上下文 JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]; // 直接调用JS的函数,还可以向函数里面传入需要的参数.在XCode中向JS中的alert传入需要的message NSString *textJS = @"showAlert('这个message是XCode中传入的')"; // 执行这个JS代码 [context evaluateScript:textJS];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end JSContextDemo.html文件： 123456789101112131415161718192021222324252627282930&lt;html&gt; &lt;header&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 分享标签的点击事件 function shareBtnClick() &#123; // 定义一个分享函数,作为页面分享操作的标记,类似于自定义协议头一样的 share(); &#125; // JS的这个方法是准备好的给OC调用的,而且OC那边还可以传参数进来 function showAlert(message)&#123; alert(message); &#125; &lt;/script&gt; &lt;/header&gt; &lt;body&gt; &lt;h2&gt; JSContextDemo &lt;/h2&gt; &lt;br/&gt; &lt;!-- 分享按钮 --&gt; &lt;button type=&quot;button&quot; onclick=&quot;shareBtnClick()&quot;&gt;分享&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS&OC交互（UIwebView）]]></title>
      <url>%2F2016%2F08%2F14%2FJS%26OC%E4%BA%A4%E4%BA%92%EF%BC%88UIwebView%EF%BC%89%2F</url>
      <content type="text"><![CDATA[oc调用js在网页加载完毕的时候修改网页内容 1234567891011121314151617181920212223242526#import "ViewController.h"@interface ViewController ()&lt;UIWebViewDelegate&gt;@property (weak, nonatomic) IBOutlet UIWebView *webView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://m.maoyan.com/newGuide/wcqp"]]; [self.webView loadRequest:request]; self.webView.delegate = self;&#125;#pragma mark - UIWebViewDelegate- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; // 使用 OC 的代码去执行JS的代码.让webView里面的内容进行改变 // 后面执行的js代码不用记,到时候咨询前端的程序员就可以了 // 移除头 [self.webView stringByEvaluatingJavaScriptFromString:@"var hd = document.getElementById('hd');hd.parentElement.removeChild(hd);"]; // 移除尾 [self.webView stringByEvaluatingJavaScriptFromString:@"var ft = document.getElementById('ft');ft.parentElement.removeChild(ft);"];&#125;&#125; 调用js语句之前：需要删除 网页头部视图 与 网页尾部视图 调用js语句之后： js调用oc: 与前端的程序员定一个自定义的协议头,然后在该方法里面判断是否是这个协议头,如果是,不去加载页面,并且做自己事情就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#import "ViewController.h"@interface ViewController ()&lt;UIWebViewDelegate&gt;@property (weak, nonatomic) IBOutlet UIWebView *webView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://m.maoyan.com/newGuide/wcqp?uuid=82981ACB37B65C58C702647A8D18849A9A0962CE44E9F6BAD28B0A4B06BB8314&amp;utm_term=7.1.1&amp;utm_source=AppStore&amp;utm_content=82981ACB37B65C58C702647A8D18849A9A0962CE44E9F6BAD28B0A4B06BB8314&amp;version_name=7.1.1&amp;utm_medium=iphone&amp;lat=40.058798&amp;utm_campaign=AmovieBmovieH0&amp;pushToken=548bf2eb%201d53e305%20b09aafda%20299abdf7%20680c708f%20c404644d%20fbf0c996%20632dc364&amp;lng=116.335873&amp;f=ios&amp;cityId=1&amp;ci=1&amp;msid=D061DF57-2504-45E7-B9DB-34DD13A838892016-08-14-%E4%B8%8A%E5%8D%889-30800"]]; [self.webView loadRequest:request]; self.webView.delegate = self;&#125;#pragma mark - UIWebViewDelegate/** * 是否要加载某个请求,如果返回true,代表要加载该请求,如果返回false,那么代表不去加载这个请求 * 我们可以在这个方法里面去监听webView当前加载的地址 * 如果以后开发中,遇到:点击webView中某个按钮,要弹出原生控件的话,就可以去与前端的程序员定一个自定义的协议头,然后在该方法里面判断是否是这个协议头,如果是,不去加载页面,并且做自己事情就可以了 * * @param webView &lt;#webView description#&gt; * @param request &lt;#request description#&gt; * @param navigationType &lt;#navigationType description#&gt; * * @return &lt;#return value description#&gt; */- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // 如何取出当前webView加载的是哪个网址? // 如果url是以 meituanmovie 开头的话,那么就去打开原生的界面 NSString *urlString = request.URL.absoluteString; NSLog(@"%@", urlString); // 判断一下协议头是否是我们自己的 if ([urlString hasPrefix:@"meituanmovie"]) &#123; // 如果是,就打开原生的页面 NSLog(@"打开原生页面,参数是:%@", request.URL.query); // .......... return false; &#125; return true;&#125;- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; // 使用 OC 的代码去执行JS的代码.让webView里面的内容进行改变 // 后面执行的js代码不用记,到时候咨询前端的程序员就可以了 // 移除头 [self.webView stringByEvaluatingJavaScriptFromString:@"var hd = document.getElementById('hd');hd.parentElement.removeChild(hd);"]; // 移除尾 [self.webView stringByEvaluatingJavaScriptFromString:@"var ft = document.getElementById('ft');ft.parentElement.removeChild(ft);"];&#125;@end NSLog输出： 1232016-08-14 23:01:35.703 oc与js互调[40973:1822781] http://m.maoyan.com/newGuide/wcqp?uuid=82981ACB37B65C58C702647A8D18849A9A0962CE44E9F6BAD28B0A4B06BB8314&amp;utm_term=7.1.1&amp;utm_source=AppStore&amp;utm_content=82981ACB37B65C58C702647A8D18849A9A0962CE44E9F6BAD28B0A4B06BB8314&amp;version_name=7.1.1&amp;utm_medium=iphone&amp;lat=40.058798&amp;utm_campaign=AmovieBmovieH0&amp;pushToken=548bf2eb%201d53e305%20b09aafda%20299abdf7%20680c708f%20c404644d%20fbf0c996%20632dc364&amp;lng=116.335873&amp;f=ios&amp;cityId=1&amp;ci=1&amp;msid=D061DF57-2504-45E7-B9DB-34DD13A838892016-08-14-%E4%B8%8A%E5%8D%889-308002016-08-14 23:01:44.603 oc与js互调[40973:1822781] meituanmovie://www.meituan.com/movie_schedule?id=247713&amp;nm=%E5%8D%B1%E5%9F%8E&amp;index=reserve2016-08-14 23:01:44.604 oc与js互调[40973:1822781] 打开原生页面,参数是:id=247713&amp;nm=%E5%8D%B1%E5%9F%8E&amp;index=reserve]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[截屏 & 图片缩放（Swift）]]></title>
      <url>%2F2016%2F07%2F14%2F%E6%88%AA%E5%B1%8F%20%26%20%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE%EF%BC%88Swift%EF%BC%89%2F</url>
      <content type="text"><![CDATA[截屏的功能: 1234567891011121314151617181920private func getScreenSnap() -&gt; UIImage? &#123; // 先获取到window let window = UIApplication.shared.keyWindow! // 开启上下文 // 如果最后一参数传入0的话，会按照屏幕的真实大小来截取，就是不会截取缩放之后的内容 UIGraphicsBeginImageContextWithOptions(window.bounds.size, false, 0) // 将window的内容渲染到上下文中 window.drawHierarchy(in: window.bounds, afterScreenUpdates: false) // 取到上下文中的图片 let image = UIGraphicsGetImageFromCurrentImageContext() // 关闭上下文 UIGraphicsEndImageContext() // 返回结果 return image&#125; 缩放到指定的宽度: 12345678910111213141516171819func scaleTo(width: CGFloat) -&gt; UIImage &#123; if self.size.width &lt; width &#123; return self &#125; // 根据宽度求出等比例缩放之后的高度 let height = self.size.height * (width / self.size.width) // 定义一个范围 let rect = CGRect(x: 0, y: 0, width: width, height: height) // 开启上下文 UIGraphicsBeginImageContext(rect.size) // 会将当前图片的所有内容完整的画到上下文中 self.draw(in: rect) // 取值 let result = UIGraphicsGetImageFromCurrentImageContext()! // 关闭上下文 UIGraphicsEndImageContext() return result&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用第三方开源库是否应该做二次封装（转）]]></title>
      <url>%2F2016%2F02%2F14%2F%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E5%BA%93%E6%98%AF%E5%90%A6%E5%BA%94%E8%AF%A5%E5%81%9A%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85%EF%BC%88%E8%BD%AC%EF%BC%89%2F</url>
      <content type="text"><![CDATA[现在有大量的开源第三方库，大家几乎每个项目都有用到。而这些库基本都提供了非常友好的接口，供应用层使用。但是，考虑到版本升级，程序员的水平，甚至使用许可等方面的问题，我考虑对未来大多数要使用的第三方库进行二次封装。下面是我想到的基于多人开发，有可能发布多次升级版本的情况下的优缺点。 优点：1：当自己的软件版本升级时，可能会出现需要更换第三方库的情况，一个库的使用不能满足新的需求，这时，如果使用了二次封装，那么库的更改和自己编写的应用层就可以脱离，只需要改写二次封装就可以实现。避免了走入应用层，改写大量的代码甚至软件流程和架构。2：当第三方库发生官方升级和出现了官方对已知局限性及BUG的修订时，只需要在二次封装的接口层改动即可。3：当需求必须对第三方库添加额外功能时，可以添加在二次封装层，避免了对第三方库本身的修改，减少了潜在危险。4：新开发人员只需要对二次封装学习就能快速上手，因为二次封装是之前开发人员留下的成果，公司内部有丰富的资料和统一的编码风格，相对于第三方库本身学习要容易和快捷。5：大家补充下。 缺点：1：额外工作量：多数第三方库有比较友好的接口，添加一个二次封装会导致开发人员的首次开发中投入相对于直接使用第三方库较多的时间和精力。2：针对优点3——直接修改第三方库： 1．代码编写数量少：对库自身代码的改动往往只需要简单的代码就能实现外部改动需要较多代码数量的需求。 2．运行效率高：嵌入在第三方库内部空间内的功能，必然要比在第三方库外添加的功能运行效率高。 个人理解：如果是还有人维护的第三方开源库，项目组人力不足的情况下，不进行二次封装，也不会有很大的风险。 如果开源库已经没有人维护，或者遇到问题响应速度非常慢，还是需要考虑进行二次封装。 总的来说，我喜欢进行二次封装，自己掌握主动。 原文地址：http://blog.csdn.net/pizi0475/article/details/7771811]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[视频截图，录制，压缩方式]]></title>
      <url>%2F2015%2F07%2F20%2F%E8%A7%86%E9%A2%91%E6%88%AA%E5%9B%BE%EF%BC%8C%E5%BD%95%E5%88%B6%EF%BC%8C%E5%8E%8B%E7%BC%A9%2F</url>
      <content type="text"><![CDATA[视频截图:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import "ViewController.h"#import &lt;AVFoundation/AVFoundation.h&gt;/** 1. 导入AVFountaion框架 2. 创建图像资源生成器 3. 调用方法, 来获取指定时间的截图 */@interface ViewController ()@property (weak, nonatomic) IBOutlet UIImageView *imageView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; //1. 获取URL NSURL *url = [[NSBundle mainBundle] URLForResource:@"Cupid_高清.mp4" withExtension:nil]; //2. 创建资源 --&gt; 找视频 AVAsset *asset = [AVAsset assetWithURL:url]; //3. 创建图像资源生成器 AVAssetImageGenerator *generator = [AVAssetImageGenerator assetImageGeneratorWithAsset:asset]; //4. 创建CMTime: 专们用于表示影片时间的值 //帧数: 1S 24帧. 15~30 3gp:10~15 //影片截图: 用第几秒+第几帧, 这样来获取比较合适 //value: 你要获取第几帧 //timescale: 一秒有几帧 //time的结果 = value / timescale 单位是秒+帧 CMTime time = CMTimeMake(1, 1); NSValue *value = [NSValue valueWithCMTime:time]; //5. 指定时间, 异步生成图像 [generator generateCGImagesAsynchronouslyForTimes:@[value] completionHandler:^(CMTime requestedTime, CGImageRef _Nullable image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError * _Nullable error) &#123; //这里不能使用桥接 //self.imageView.image = (__bridge UIImage * _Nullable)(image); //6. 在主线程中更新UI dispatch_sync(dispatch_get_main_queue(), ^&#123; self.imageView.image = [UIImage imageWithCGImage:image]; &#125;); &#125;];&#125;@end 视频录制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#import "ViewController.h"#import &lt;MobileCoreServices/MobileCoreServices.h&gt;#import &lt;MediaPlayer/MediaPlayer.h&gt;#import &lt;AssetsLibrary/AssetsLibrary.h&gt;@interface ViewController ()&lt;UINavigationControllerDelegate, UIImagePickerControllerDelegate&gt;@property (nonatomic, strong) MPMoviePlayerController *mpC;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.&#125;/** 点击屏幕录制视频 播放刚才录制的视频 保存视频 iOS10注意添加授权Key */- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; //1. 先判断源类型是否可用 if (![UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypePhotoLibrary]) &#123; return; &#125;; //2. 创建 UIImagePickerController *pickerC = [UIImagePickerController new]; //3. 设置源类型 (默认就是UIImagePickerControllerSourceTypePhotoLibrary) //PhotoLibrary: 选择视频 //Camera: 录制视频 pickerC.sourceType = UIImagePickerControllerSourceTypeCamera; //4. 设置媒体类型 默认是Image, kUTTypeImage = @"public.movie" pickerC.mediaTypes = @[(NSString *)kUTTypeMovie]; //5. 设置代理 pickerC.delegate = self; //6. 模态弹出控制器 [self presentViewController:pickerC animated:YES completion:nil];&#125;#pragma mark picker的代理方法- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123; NSLog(@"info: %@", info); /** UIImagePickerControllerMediaType = "public.movie"; UIImagePickerControllerMediaURL = "file:///private/var/mobile/Containers/Data/Application/0DF55A9B-89D5-4477-BE3A-6CBAB2912419/tmp/49794758578__D28D3F45-60D0-47AE-9789-04698E5808A6.MOV"; */ //保存视频 //此代理方法, 从相册选中一个照片/拍照/选中视频/录制视频都会走这个方法. //只有录制视频这种情况才需要保存视频 //1. 保证媒体类型是视频 --&gt; Movie NSString *meidaTypeStr = info[UIImagePickerControllerMediaType]; if ([meidaTypeStr isEqualToString:@"public.movie"]) &#123; if (self.mpC == nil) &#123; //强引用, 设置Frame, 添加到View上, 调用播放方法 self.mpC = [MPMoviePlayerController new]; self.mpC.view.frame = CGRectMake(0, 0, 375, 500); [self.view addSubview:self.mpC.view]; &#125;; //网址不一样. 播放方法 //UIImagePickerControllerMediaURL: 是视频地址, 也需要保证媒体类型是视频 self.mpC.contentURL = info[UIImagePickerControllerMediaURL]; [self.mpC play]; //2. 保证是录制视频 (如果是选中了视频, 说明视频已经存在了. 如果你在保存, 就重复了) //说明现在是录制视频 if (picker.sourceType == UIImagePickerControllerSourceTypeCamera) &#123; //3. 保存 ALAssetsLibrary *al = [ALAssetsLibrary new]; //保存视频到系统的默认相册中 --&gt; 只需要传入要保存的视频的URL地址即可 [al writeVideoAtPathToSavedPhotosAlbum:info[UIImagePickerControllerMediaURL] completionBlock:nil]; &#125; &#125; //一旦实现了代理方法, 那么picker需要手动消失 [picker dismissViewControllerAnimated:YES completion:nil];&#125;@end 视频压缩12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#import "ViewController.h"#import &lt;MobileCoreServices/MobileCoreServices.h&gt;#import &lt;AVFoundation/AVFoundation.h&gt;@interface ViewController ()&lt;UINavigationControllerDelegate, UIImagePickerControllerDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.&#125;- (IBAction)chooseVideoClick:(id)sender &#123; /* enum &#123; UIImagePickerControllerSourceTypePhotoLibrary ,//来自图库 UIImagePickerControllerSourceTypeCamera ,//来自相机 UIImagePickerControllerSourceTypeSavedPhotosAlbum //来自相册 &#125;; */ if (![UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypePhotoLibrary]) &#123; return; &#125; UIImagePickerController *picker = [UIImagePickerController new]; //可以控制是选择(PhotoLibrary)/拍摄(Camera) picker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary; //可以控制是照片(kUTTypeImage)/视频(kUTTypeMovie) picker.mediaTypes = @[(NSString *)kUTTypeMovie]; picker.delegate = self; [self presentViewController:picker animated:YES completion:nil];&#125;#pragma mark 代理方法 --&gt; 获取视频的URL地址, 并进行压缩- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123; NSLog(@"info: %@",info); /** UIImagePickerControllerMediaURL = "file:///private/var/mobile/Containers/Data/Application/F7867122-B08D-46E9-86DD-09EC7BEF7208/tmp/trim.EF7DA639-689D-4C56-A12B-8DE97CC226C2.MOV"; UIImagePickerControllerReferenceURL = "assets-library://asset/asset.MOV?id=E00E435A-84F3-45CC-8604-D4981B1C89EB&amp;ext=MOV"; */ //转换视频 [self export:info[UIImagePickerControllerMediaURL]];&#125;#pragma mark 视频压缩代码 转换视频- (void)export:(NSURL *)url&#123; //1. 创建资源类 AVAsset *asset = [AVAsset assetWithURL:url]; //2. 创建资源转换会话类 //presetName: 设置分辨率和质量 可以选择低或中质量 AVAssetExportSession *exportSession = [AVAssetExportSession exportSessionWithAsset:asset presetName:AVAssetExportPresetLowQuality]; //3. 转换的路径 从沙盒中指定路径 --&gt; 变成NSURL //文件重名, 不会默认覆盖 //temp://video/abc.mp4 exportSession.outputURL = [NSURL fileURLWithPath: [NSTemporaryDirectory() stringByAppendingPathComponent:@"2.mp4"]]; //4. 转换的格式 exportSession.outputFileType = AVFileTypeMPEG4; /** "com.apple.quicktime-movie" --&gt; AVFileTypeQuickTimeMovie "public.mpeg-4" --&gt; AVFileTypeMPEG4 */ //NSLog(@"session: %@", exportSession.supportedFileTypes); //5. 转换方法 , 转成功, 会调用里面的block [exportSession exportAsynchronouslyWithCompletionHandler:^&#123; NSLog(@"转换成功"); //在这里执行发送视频的代码 &#125;];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[传感器：加速计,陀螺仪,磁力计 push获取方式]]></title>
      <url>%2F2015%2F06%2F28%2F%E4%BC%A0%E6%84%9F%E5%99%A8%EF%BC%9A%E5%8A%A0%E9%80%9F%E8%AE%A1%2C%E9%99%80%E8%9E%BA%E4%BB%AA%2C%E7%A3%81%E5%8A%9B%E8%AE%A1%20push%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[传感器：加速计,陀螺仪,磁力计 push获取方式 获取方式分为2种: push(系统会按照一定的时间间隔, 不停的返回数据) / pull (在需要的时候再来获取数据) 加速计: 检测力在某个方向上有作用 (检测到方向和大小) –&gt; 沿着轴上下快速运动 加速度计的原理很简单，现在手机里面基本配备的都是3维线传感器，也就是说，用来测量x，y，z三个轴上的加速力。加速力就是当物体在加速过程中作用在物体上的力，就好比地球引力，也就是重力。 可以用于监测设备的摇晃 123456789101112131415161718192021222324252627282930- (void)accelerometerPush &#123; //加速器push (频繁获取数据) //Accelerometer //1. 创建运动管理器 self.motionMgr = [CMMotionManager new]; //2. 判断能否使用加速计 if (![self.motionMgr isAccelerometerAvailable]) &#123; return; &#125; //3. 设置采样间隔(更新间隔/推送间隔) --&gt; push方式才需要设置 //单位是秒 self.motionMgr.accelerometerUpdateInterval = 1; //4. 开始更新 --&gt; 如果是push方式, 那么使用带有bolck的方法 [self.motionMgr startAccelerometerUpdatesToQueue:[NSOperationQueue mainQueue] withHandler:^(CMAccelerometerData * _Nullable accelerometerData, NSError * _Nullable error) &#123; /** 1. 哪个轴方向指向地面方向, 就会打印哪个轴方向的值. 2. 默认的大小 1~-1之间 3. 沿着轴方向运动, 会改变大小 如果要实现摇一摇, 可以判断三个轴的任何一个, 只要大于某个数值, 就可以判定发生了摇一摇 */ CMAcceleration acceleration = accelerometerData.acceleration; NSLog(@"x: %f, y: %f, z: %f ", acceleration.x, acceleration.y, acceleration.z); &#125;];&#125; 陀螺仪: 检测转动的角速度 –&gt; 只有转动才会有值 陀螺仪原理是指陀螺仪工作的原理，螺旋仪是一种用来传感与维持方向的装置，基于角动量守恒的理论设计出来的。陀螺仪主要是由一个位于轴心且可旋转的转子构成。 陀螺仪一旦开始旋转，由于转子的角动量，陀螺仪有抗拒方向改变的趋向。 现象解释[百度百科] 高速旋转的物体的旋转轴，对于改变其方向的外力作用有趋向于垂直方向的倾向。而且，旋转物体在横向倾斜时，重力会向增加倾斜的方向作用，而轴则向垂直方向运动，就产生了摇头的运动（岁差运动）。当陀螺经纬仪的陀螺旋转轴以水平轴旋转时，由于地球的旋转而受到铅直方向旋转力，陀螺的旋转体向水平面内的子午线方向产生岁差运动。当轴平行于子午线而静止时可加以应用。 陀螺仪基本上就是运用物体高速旋转时，角动量很大，旋转轴会一直稳定指向一个方向的性质，所制造出来的定向仪器。不过它必需转得够快，或者惯量够大(也可以说是角动量要够大)。不然，只要一个很小的力矩，就会严重影响到它的稳定性。 陀螺仪的测量是随时间累计的，要知道当前的角度，只需要将之前所有的输出数值积分即可。当然，陀螺仪只会输出当前旋转的变化值，比如说，如果一架飞机是以60度的倾斜角度径直飞行，此时陀螺仪的输出为0，因为当前就没有机体旋转。但是，你可以通过之前的输出累计计算出当前机体倾斜角度是多少。 123456789101112131415161718192021222324- (void)gyroPush&#123; //陀螺仪push (频繁获取数据) //Gyro //1. 创建运动管理器 self.motionMgr = [CMMotionManager new]; //2. 判断能否使用陀螺仪 if (![self.motionMgr isGyroAvailable]) &#123; return; &#125; //3. 设置采样间隔(更新间隔/推送间隔) --&gt; push方式才需要设置 //单位是秒 self.motionMgr.gyroUpdateInterval = 1; //4. 开始更新 --&gt; 如果是push方式, 那么使用带有bolck的方法 [self.motionMgr startGyroUpdatesToQueue:[NSOperationQueue mainQueue] withHandler:^(CMGyroData * _Nullable gyroData, NSError * _Nullable error) &#123; CMRotationRate rotationRate = gyroData.rotationRate; NSLog(@"x: %f, y: %f, z: %f ", rotationRate.x, rotationRate.y, rotationRate.z); &#125;];&#125;@end 磁力计: 检测磁场的变化 –&gt; 主要用于导航 感应周边磁场，盒盖锁屏 123456789101112131415161718192021222324252627- (void)gyroPush&#123;-(void)magnetometerPush&#123; //磁力计push (频繁获取数据) //Magnetometer //1. 创建运动管理器 self.motionMgr = [CMMotionManager new]; //2. 判断能否使用磁力计 if (![self.motionMgr isMagnetometerAvailable]) &#123; return; &#125; //3. 设置采样间隔(更新间隔/推送间隔) --&gt; push方式才需要设置 //单位是秒 self.motionMgr.magnetometerUpdateInterval = 1; //4. 开始更新 --&gt; 如果是push方式, 那么使用带有bolck的方法 [self.motionMgr startMagnetometerUpdatesToQueue:[NSOperationQueue mainQueue] withHandler:^(CMMagnetometerData * _Nullable magnetometerData, NSError * _Nullable error) &#123; //单位: 特斯拉 CMMagneticField magneticField = magnetometerData.magneticField; NSLog(@"x: %f, y: %f, z: %f ", magneticField.x, magneticField.y, magneticField.z); &#125;];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[传感器：加速计,陀螺仪,磁力计 pull获取方式]]></title>
      <url>%2F2015%2F06%2F27%2F%E4%BC%A0%E6%84%9F%E5%99%A8%EF%BC%9A%E5%8A%A0%E9%80%9F%E8%AE%A1%2C%E9%99%80%E8%9E%BA%E4%BB%AA%2C%E7%A3%81%E5%8A%9B%E8%AE%A1%20pull%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[传感器：加速计,陀螺仪,磁力计 pull获取方式 获取方式分为2种: push(系统会按照一定的时间间隔, 不停的返回数据) / pull (在需要的时候再来获取数据) 陀螺仪,磁力计操作方法类似 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import "ViewController.h"#import &lt;CoreMotion/CoreMotion.h&gt;@interface ViewController ()//运动管理器@property (nonatomic, strong) CMMotionManager *motionMgr;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; /** 加速计: 检测力在某个方向上有作用 (检测到方向和大小) --&gt; 沿着轴上下快速运动 */ //加速器pull (在需要的时候再来获取数据) //Accelerometer //1. 创建运动管理器 self.motionMgr = [CMMotionManager new]; //2. 判断能否使用加速计 if (![self.motionMgr isAccelerometerAvailable]) &#123; return; &#125; //3. 开始更新 [self.motionMgr startAccelerometerUpdates];&#125;#pragma mark 点击屏幕获取数组- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; //加速计 / 陀螺仪 / 磁力计, 在开始更新数据之后, 都会讲获取的数据, 保存到对应的属性中. 可以从属性中直接获取想要的数据 //加速 CMAcceleration acceleration = self.motionMgr.accelerometerData.acceleration; NSLog(@"x: %f, y: %f, z: %f ", acceleration.x, acceleration.y, acceleration.z);// CMRotationRate rotationRate = self.motionMgr.gyroData.rotationRate;// NSLog(@"x: %f, y: %f, z: %f ", rotationRate.x, rotationRate.y, rotationRate.z);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[控制器创建方式]]></title>
      <url>%2F2014%2F12%2F27%2F1.%E6%8E%A7%E5%88%B6%E5%99%A8%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[控制器的三种创建方式-代码 直接alloc init 控制器的三种创建方式-sb 首先都要获取 sb 对象 两种方式: 获取箭头所指向的控制器 (不带参数的) 获取指定sbID的控制器 (带参数的) 控制器的三种创建方式-xib 三种: 指定xib的名字 (创建控制器的时候的init的方法) 同名xib 同名去掉Controller的xib 注意: xib的filesOwner为类名 view要记得连线 用 XIB 加载控制器的细节 优先级: 如果指定的xib的名字,回去加载执行的xib 如果没有指定xib的名字 如果有同名的xib,会去加载同名的xib 如果没有同名的xib 如果有同名去掉Controller的xib,会去加载同名去掉Controller的xib 如果没有同名去掉Controller的xib,会创建一个空白的控制器 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940AppDelegate.m - (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions&#123; // Override point for customization after application launch. self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];// 1. 代码 TestViewController* vc = [[TestViewController alloc] init];// 2.通过sb加载控制器2.1 加载箭头所指向的控制器 // 2.1.1 获取sb对象 UIStoryboard* sb = [UIStoryboard storyboardWithName:@"Test" bundle:nil]; // 2.1.2 加载箭头所指向的控制器 TestViewController* vc = sb.instantiateInitialViewController;2.2 加载一个带sbID的控制器 // 2.2.1 获取sb对象 UIStoryboard* sb = [UIStoryboard storyboardWithName:@"Test" bundle:nil]; // 2.2.2 加载一个带sbID的控制器 TestViewController* vc = [sb instantiateViewControllerWithIdentifier:@"test"];// 3.通过xib的形式加载控制器 (同名的xib优先级会比同名去掉Controller的要高!!!) // 3.1 指定xib名称 OneViewController* vc = [[OneViewController alloc] initWithNibName:@"Testtt" bundle:nil]; // 3.2 通过init的方法创建 (同名的xib) // 当调用init方法创建的时候 系统会尝试加载同名的xib OneViewController* vc = [[OneViewController alloc] init];// 3.3 通过init的方法创建 (同名去掉Controller的xib) // 当调用init方法创建的时候 系统会尝试加载同名去掉Controller的xib OneViewController* vc = [[OneViewController alloc] init]; self.window.rootViewController = vc; [self.window makeKeyAndVisible]; return YES;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图像绘制]]></title>
      <url>%2F2014%2F12%2F22%2F%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6%2F</url>
      <content type="text"><![CDATA[Quartz2D/Core Graphics介绍 Quartz2D的API是哪个语言的? c语言 Quartz2D的API来自于哪个框架? Core Graphics Quartz2D可以做什么? 饼状图,柱状图,折线图 自定义控件 Quartz2D 支持 iOS 开发, mac 开发, 跨平台 图形上下文介绍 图形上下文也叫做绘图上下文 图形上下文的类型? CGContextRef 图形上下文包含的主要信息? 路径(圆,方,线条) 状态(红色,多宽) 输出目标(在哪显示) 绘图的步骤/方式/静态分析工具 绘图的步骤有哪些? 获取当前上下文 拼接路径 同时 把路径添加到上下文当中 渲染 静态分析工具的作用? 不仅能够检测内存泄漏的问题,还能检测其他的问题. 这个工具仅仅是静态的在分析内存的问题,并不能真正的检测内存泄漏的问题. 如何释放路径? CGPathRelease(path); CFRelease(path); ARC仅仅是处理oc的引用计数的问题 在c中如果看到了create/copy/retain,一般都需要释放 12345678910111213141516171819202122232425262728293031323334353637// 步骤和方式- (void)test1&#123; // 绘图的步骤// 方式1 // 1.获取当前图形上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 2.拼接路径 同时 把路径添加到上下文当中 CGContextMoveToPoint(ctx, 100, 100); // 起点 CGContextAddLineToPoint(ctx, 200, 200); // 终点 // 3.渲染(显示) CGContextStrokePath(ctx);// 方式2 // 1.获取当前图形上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 2.拼接路径 CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, NULL, 100, 100); CGPathAddLineToPoint(path, NULL, 200, 200); // 3.把路径添加到上下文当中 CGContextAddPath(ctx, path); // 4.渲染(显示) CGContextStrokePath(ctx); // // 释放 CGPathRelease(path); // CFRelease(path);//可以释放所有Core foundation对象&#125; 绘图实例 矩形 addRect 1234567891011121314- (void)drawRect:(CGRect)rect&#123; // 矩形 // 获取上下文 uijjcc: CGContextRef ctx = UIGraphicsGetCurrentContext(); // 拼接路径 同时 添加到上下文当中 CGContextAddRect(ctx, CGRectMake(100, 100, 100, 100)); // 渲染 CGContextStrokePath(ctx);&#125; 椭圆 addEllipse 12345678910// 椭圆 // 获取上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 路径 CGContextAddEllipseInRect(ctx, CGRectMake(100, 100, 100, 100)); // 渲染 CGContextStrokePath(ctx); 弧 addArc 1234567891011121314// 弧 // 上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 路径 // x , y 圆心 // radius 半径 // start 起始的位置 // end 结束的位置 // clockwise 是否是顺时针 CGContextAddArc(ctx, 150, 150, 100, 0, M_PI_2, 1); // 渲染 CGContextStrokePath(ctx); 绘图的样式 线宽? CGContextSetLineWidth 头尾样式? CGContextSetLineCap 连接处样式? CGContextSetLineJoin 虚线? CGContextSetLineDash 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (void)drawRect:(CGRect)rect&#123; // 画线 // 上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 路径 CGContextMoveToPoint(ctx, 50, 100); CGContextAddLineToPoint(ctx, 250, 100); // CGContextAddLineToPoint(ctx, 200, 200);// 设置线宽 CGContextSetLineWidth(ctx, 100);//对上下文所有的东西进行操作，渲染的时候起作用// 设置头尾样式 CGContextSetLineCap(ctx, kCGLineCapSquare); // kCGLineCapButt, // 默认 // kCGLineCapRound, // 圆角 // kCGLineCapSquare // 方的,两头会加宽度的一半// 设置连接处的样式 CGContextSetLineJoin(ctx, kCGLineJoinBevel); // kCGLineJoinMiter, // 默认 // kCGLineJoinRound, // 圆角 // kCGLineJoinBevel // 切角// 虚线 // phase 阶段 通常传0 // lengths 数组 // count 数组长度 // CGFloat lengths[] = &#123; 10, 20 &#125;; // 长度 10 间距20 // CGFloat lengths[] = &#123; 10, 20, 30 &#125;; // 长度 10 间距 20 长度 30 间距10 长度 20 间距30 长度 10 间距 20 CGFloat lengths[] = &#123; 10, 20, 30 &#125;; CGContextSetLineDash(ctx, 30, lengths, 3); // 渲染 CGContextStrokePath(ctx);&#125; 渲染的方式/绘图的颜色 关闭路径? CGContextClosePath(ctx); // 从当前的位置 连线 到初始的位置 描边? stork 填充? fill color对象的 set/setFill/setStrok 区别? setFill 仅仅是设置填充的颜色 setStrok 仅仅是设置描边的颜色 set 两个都设置 123456789101112131415161718192021222324252627// 渲染的方法- (void)test6&#123; // 三角形 // 上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 路径 CGContextMoveToPoint(ctx, 100, 100); CGContextAddLineToPoint(ctx, 200, 100); CGContextAddLineToPoint(ctx, 150, 200); CGContextClosePath(ctx); // 从当前的位置 连线 到初始的位置 // 设置颜色oc [[UIColor redColor] setFill];//填充颜色 [[UIColor whiteColor] set];//线的颜色 [[UIColor blueColor] setStroke];//对两者都进行设定 // 渲染 CGContextDrawPath(ctx, kCGPathFillStroke);//对 填充和描边 进行渲染 // CGContextFillPath(ctx); // CGContextDrawPath(ctx, kCGPathStroke); &lt;==&gt; CGContextStrokePath(ctx); // CGContextDrawPath(ctx, kCGPathFill); &lt;==&gt; CGContextFillPath(ctx);&#125; 补充-不同样式的线 如果想要出现不同样式的线 需要渲染多次 渲染的过程,仅仅是把路径信息,渲染上去.这个时候,当前上下文还在,路径信息,如果被渲染以后,就没有了.但是,状态信息和目标信息都还在 两条线 一条粗，一条细 12345678910111213141516171819202122// 不同样式的线- (void)test7&#123; // 上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); CGContextSetLineWidth(ctx, 25); // 路径 CGContextMoveToPoint(ctx, 100, 100); CGContextAddLineToPoint(ctx, 100, 200); // 渲染：渲染的过程，是把当前所有的东西全都剪切到UIView。 CGContextStrokePath(ctx); //从新设定上下文 CGContextSetLineWidth(ctx, 20); CGContextMoveToPoint(ctx, 200, 100); CGContextAddLineToPoint(ctx, 200, 200); CGContextStrokePath(ctx);&#125; 奇偶填充规则 even odd 不是默认的填充规则,如果需要使用需要调用 EOFill 奇填偶不填 参考代码: 12345678910111213// 奇偶填充规则-(void)test8&#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); CGContextAddArc(ctx, 150, 150, 100, 0, 2 * M_PI, 0); CGContextAddRect(ctx, CGRectMake(100, 100, 100, 100)); CGContextAddRect(ctx, CGRectMake(120, 20, 50, 250)); CGContextDrawPath(ctx, kCGPathEOFill);//eo：奇偶--奇填偶不填，如果只是kCGPathFill：就是一坨黑&#125; 非零环绕数规则 如果是从右往左 +1 如果是从左往右 -1 如果最终结果不为0 那么填充 非零环绕数是默认的填充规则 参考代码: 1234567891011121314151617181920- (void)drawRect:(CGRect)rect&#123; // Drawing code CGContextRef ctx = UIGraphicsGetCurrentContext(); CGMutablePathRef path1 = CGPathCreateMutable(); CGMutablePathRef path2 = CGPathCreateMutable(); CGPathAddArc(path1, NULL, 150, 150, 100, 0, 2 * M_PI, 1); CGPathAddArc(path2, NULL, 150, 150, 80, 0, 2 * M_PI, 0); // CGContextAddPath(ctx, path1); CGContextAddPath(ctx, path2); CGContextFillPath(ctx); CGPathRelease(path1); CGPathRelease(path2);&#125; 关于drawRect1234567891011121314//- 为什么要把代码写在drawRect当中?// 因为这个方法可以获取到正确的上下文//- drawrect方法中rect参数的含义是什么?// 当前view的bounds//- drawrect什么时候调用?// 这个方法是系统自动调用,不要手动调用// 1.当这个view第一次显示的时候会调用// 2.当重绘的时候会调用//- 如何重绘?// 1.调用需要重绘的对象的 setNeedsDisplay// 2.调用需要重绘的对象的 setNeedsDisplayInRect UIKit绘制图形 &lt;oc&gt;画一条线 12345678910111213141516-(void)drawRect:(CGRect)rect&#123; //Crawing code//1.path对象 UIBezierPath *path = [[UIBezierPath alloc]init];//2.路径 //线 [path moveToPoint:CGPointMake(100, 100)]; [path addLineToPoint:CGPointMake(200, 200)];//3.渲染 [path stroke];&#125; 矩形 bezierPathWithRect 椭圆 bezierPathWithOvalInRect 圆角矩形 bezierPathWithRoundedRect 圆角矩形 超过了半径的三分之二 会变成一个圆 圆 bezierPathWithArcCenter c 和 oc 的区别? Quartz2d是C的api c的功能比oc的强大 oc仅仅是封装了一部分c的api 从代码量上来说 oc比c 简单 一般情况,工作中用oc.如果oc实现不了的功能用c 1234567891011121314151617181920212223-(void)drawRect:(CGRect)rect&#123; //Crawing code//1.矩形 UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(100, 100, 100, 100)]; [path stroke];//2.椭圆 UIBezierPath *path1 = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)]; [path1 stroke];//3.圆角矩形 UIBezierPath *path2 = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(100, 100, 100, 100) cornerRadius:30];//50正好，超过了半径的2/3的话 会变成一个圆 [path2 stroke];//4.弧 UIBezierPath *path3 = [UIBezierPath bezierPathWithArcCenter:CGPointMake(150, 150) radius:100 startAngle:0 endAngle:M_PI_2 clockwise:1]; [path3 stroke];&#125; oc和c混用 c和oc可以混用 c如何转成oc的path 通过类方法 传入 CGPath oc如何转成c的path 直接通过ocPath的.CGPath即可 123456789101112131415161718192021222324252627-(void)drawRect:(CGRect)rect&#123; //1.c方法 //上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); //路径 CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, NULL, 100, 100); CGPathAddLineToPoint(path, NULL, 200, 200); //oc路径 UIBezierPath *ocPath = [UIBezierPath bezierPathWithCGPath:path]; [ocPath addLineToPoint:CGPointMake(200, 100)];// [ocPath stroke];//oc显示// 将oc转化成c的path并添加到上下文 //CGContextAddPath(ctx, path); CGContextAddPath(ctx, ocPath.CGPath); CGContextStrokePath(ctx); //释放c的路径 CGPathRelease(path);&#125; UIKit绘制字符串 drawInRect? drawInRect 绘制到指定的区域 drawAtPoint? // drawAtPoint 从某个点开始画 NSShadow 12345678910111213141516171819202122232425262728-(void)drawRect:(CGRect)rect&#123; //绘制字符串 NSString *str = @"我是whong7"; //创建影子 NSShadow *s = [[NSShadow alloc]init]; s.shadowOffset = CGSizeMake(100, 100);//创建影子位置 s.shadowBlurRadius = 0;//影子模糊程度，越大越模糊 s.shadowColor = [UIColor yellowColor];//影子的颜色 NSDictionary *attr = @&#123; NSFontAttributeName : [UIFont systemFontOfSize:20],//字体大小// NSBackgroundColorAttributeName:[UIColor blueColor],//背景颜色,有背景就不显示影子字了 NSForegroundColorAttributeName:[UIColor redColor],//字体颜色 NSUnderlineStyleAttributeName:@1, NSShadowAttributeName:s &#125;; //drawAtPoint 从某个点开始，不会自动换行// [str drawAtPoint:CGPointMake(0, 0) withAttributes:attr]; //drawAtRect 区域内书写，会自动换行 [str drawInRect:CGRectMake(10, 10, 100, 100) withAttributes:attr];&#125; UIKit绘制图像 drawInRect? 拉伸到指定的区域, 小图会变大 大图会变小 drawAtPoint? 从某一个点开始绘制 不变形 drawAsPatternInRect? 平铺到某个区域 不变形 可以做水印相关的东西 12345678910111213141516171819202122#import "DemoView.h"@implementation DemoView-(void)drawRect:(CGRect)rect&#123;//绘制图片 UIImage *image = [UIImage imageNamed:@"me"];//从某一个点开始绘制 [image drawAtPoint:CGPointMake(100, 100)];//拉伸 [image drawInRect:rect];//平铺 [image drawAsPatternInRect:rect];//加水印 NSString *str = @"水印"; [str drawAtPoint:CGPointMake(0, 0) withAttributes:@&#123; NSForegroundColorAttributeName:[UIColor whiteColor] &#125;];&#125; 图像保存 UIImageWriteToSavedPhotosAlbum 参数分别为 保存的图片/回调target/回调方法/标记 1234567891011121314151617181920212223242526272829- (IBAction)save:(id)sender &#123; //开启创建上下文 图片类型 的 图形上下文 UIGraphicsBeginImageContext(self.DrawView.bounds.size); //获取上下文，不用获取就可以画// CGContextRef ctx = UIGraphicsGetCurrentContext(); //把这个view 画到当前的上下文当中 并进行渲染 [self.DrawView drawViewHierarchyInRect:self.DrawView.bounds afterScreenUpdates:YES]; //获取图片 UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); //关闭 UIGraphicsEndImageContext(); // 保存相册 - 完成的是有一定要使用系统的方法 UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), @"123123123");&#125;- (void)image:(UIImage*)image didFinishSavingWithError:(NSError*)error contextInfo:(void*)contextInfo&#123; NSLog(@"保存成功"); NSLog(@"%@", contextInfo);&#125; 整体思维导图 高清思维导图下载地址绘图.png MindNode源文件下载地址绘图.mindnode 反馈与建议 微博：@whong77 邮箱：&#x77;&#104;&#x6f;&#110;&#x67;&#x37;&#57;&#x31;&#x31;&#50;&#x30;&#55;&#64;&#49;&#x36;&#51;&#46;&#99;&#111;&#x6d;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[layer简介和基本属性]]></title>
      <url>%2F2014%2F11%2F21%2Flayer%E7%AE%80%E4%BB%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[##layer简介和基本属性 CALayer 是 UIView 的一部分 layer是负责显示的,view是负责处理事件的 layer在显示反面上 一定会比view强大 view之所有能够设置 frame color 相关的属性,本质上是在给这个view的layer进行设置 边框 阴影 圆角 bounds postion属性和view.center的关系 设置内容(图片) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (void)viewDidLoad&#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UIView* redView = [[UIView alloc] init]; redView.frame = CGRectMake(100, 100, 100, 100); redView.backgroundColor = [UIColor redColor]; [self.view addSubview:redView]; self.redView = redView; // 边框 redView.layer.borderWidth = 10; redView.layer.borderColor = [UIColor blackColor].CGColor; // 阴影 redView.layer.shadowColor = [UIColor yellowColor].CGColor; // redView.layer.shadowOffset = CGSizeMake(100, 100); redView.layer.shadowOpacity = 1; // 设置layer的阴影一定要设置透明度 redView.layer.shadowRadius = 50; // 咻一咻设置圆角 redView.layer.cornerRadius = 50; redView.layer.masksToBounds = YES; // bounds 大小 redView.layer.bounds = CGRectMake(0, 0, 200, 200); // position 位置(默认是中心点)// redView.layer.position = CGPointMake(0, 0); // 内容 // 如果想把c转成oc的东西, 那么需要一个'桥接' 在桥接的后面 写上需要转化的类型 //If you are using the layer to display a static image, you can set this property to the CGImageRef containing the image you want to display. redView.layer.contents = (__bridge id)([UIImage imageNamed:@"me"].CGImage);// redView.layer.backgroundColor = [UIColor yellowColor].CGColor;&#125;- (void)touchesBegan:(NSSet&lt;UITouch*&gt;*)touches withEvent:(UIEvent*)event&#123; // 获取手指的位置 CGPoint p = [touches.anyObject locationInView:self.view]; self.redView.layer.position = p;&#125;- (void)didReceiveMemoryWarning&#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[绘制柱状图、饼状图]]></title>
      <url>%2F2014%2F11%2F15%2F%E7%BB%98%E5%88%B6%E6%9F%B1%E7%8A%B6%E5%9B%BE%E3%80%81%E9%A5%BC%E7%8A%B6%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[##柱状图 步骤: 要有数据(数据就是柱子和高度的比例) 先写一个,最后把[0]改成i即可 技巧:计算frame的时候,先写宽高,因为很多时候 x和y 是根据旷告计算的 使用oc的方式,rect的方法,把xywh传入 然后渲染 最后,嵌套for循环. 注意: setNeedsDisplayInRect 表示刷新指定的区域,但是,当这个方法调用的时候, drawRect方法的rect参数会跟着改变.所有,在drawRect方法中,尽量不要使用rect做参考. 12345678910111213141516171819202122232425262728-(void)drawRect:(CGRect)rect&#123; NSArray *data = @[@0.2,@0.5,@0.2,@0.8,@0.3,@0.9]; for (int i = 0; i&lt;data.count; i++) &#123; CGFloat w = 20; CGFloat h = self.bounds.size.height * [data[i] floatValue]; CGFloat x = i*2*w; CGFloat y = self.bounds.size.height - h; UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(x, y, w, h)]; [[UIColor randomColor]set]; [path fill]; &#125; NSLog(@"%@",NSStringFromCGRect(rect));&#125;-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;// [self setNeedsDisplay]; [self setNeedsDisplayInRect:CGRectMake(0, 0, 200, 400)];//会改变drawRect:(CGRect)rect&#125; ##饼图 步骤: 数组(扇形的比例) 如果想要画扇形,需要往圆心连线 每一次开始的位置,应该是上一次的结束的位置 每一次结束的位置,应该是在第二次的开始(上一次结束的位置) + 当前的弧的比例 嵌套for循环,渲染即可 12345678910111213141516171819202122232425262728293031323334-(void)drawRect:(CGRect)rect&#123; NSArray *data = @[@0.1,@0.2,@0.1,@0.3,@0.2,@0.1]; CGFloat start = 0; CGFloat end = 0; for (int i = 0; i&lt;data.count; i++) &#123; end = 2*M_PI*[data[i] floatValue]+start; UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(150, 150) radius:100 startAngle:start endAngle:end clockwise:1]; //扇形 记住圆心连线 [path addLineToPoint:CGPointMake(150, 150)]; [[UIColor randomColor]set]; [path fill]; start = end; &#125; NSLog(@"%@",NSStringFromCGRect(rect));&#125;-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;// [self setNeedsDisplay]; [self setNeedsDisplayInRect:CGRectMake(0, 0, 150,150)];//会改变drawRect:(CGRect)rect&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义进度条-扇形进度]]></title>
      <url>%2F2014%2F11%2F15%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%9B%E5%BA%A6%E6%9D%A1-%E6%89%87%E5%BD%A2%E8%BF%9B%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[##自定义进度条-扇形进度 先使用一个假的数据用来测试 起始位置和结束位置 开始 分别是 0 / :2 M_PI progress 如果想让这个圆 从十二点钟方向开始画, 需要让其实和结束分辨 减去m_pi_2即可 测试假数据,如果没问题,考虑把progress抛出去 把progress声明在.h, 然后把slider的value赋值给这个view的progress属性 在这个属性的set方法中,刷新(表示只要用户给我新值 我就应该刷新) 1234567891011121314151617181920-(void)setProgress:(CGFloat)progress&#123; _progress = progress; //只要用户给我新值，就要刷新 [self setNeedsDisplay];&#125;-(void)drawRect:(CGRect)rect&#123; //画扇形 UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(150, 150) radius:100 startAngle:0-M_PI_2 endAngle:2*M_PI*self.progress-M_PI_2 clockwise:1]; //画扇形 需要 往圆心连线 [path addLineToPoint:CGPointMake(150, 150)]; //上颜色 [[UIColor randomColor]set]; //渲染 [path fill];&#125; demo下载自定义进度条]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手势识别]]></title>
      <url>%2F2014%2F11%2F13%2F%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%2F</url>
      <content type="text"><![CDATA[##手势识别-UITapGestureRecognizer(轻敲) 两个属性: 几根手指点几下 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; //1.创建手势对象 UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapGesture:)]; //要求两根手指点击两下 tap.numberOfTapsRequired = 2;//点几下 tap.numberOfTouchesRequired = 2;//几根手指 //2.添加到需要使用收拾的对象上 [self.imageView addGestureRecognizer:tap];&#125; //3.实现收拾的操作（这个手势怎么用）-(void)tapGesture:(UITapGestureRecognizer *)sender&#123; NSLog(@"tapGesture");&#125; ##手势识别-UILongPressGestureRecognizer(长按) 误差范围 长按触发的时间 根据需求判断开始/移动的状态 state 1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; //1.创建手势对象 UILongPressGestureRecognizer *longpress = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(longPresGesture:)]; //长按时间 longpress.minimumPressDuration = .5; //手指点击时误差范围 longpress.allowableMovement = 100; //2.添加到需要使用收拾的对象上 [self.imageView addGestureRecognizer:longpress];&#125; //3.实现收拾的操作（这个手势怎么用）-(void)longPresGesture:(UILongPressGestureRecognizer *)sender&#123; //根据状态来避免一直输出 //手指点击时误差范围 引起的输出 if(sender.state == UIGestureRecognizerStateBegan) &#123; NSLog(@"longPresGesture"); &#125;&#125; ##手势识别-UISwipeGestureRecognizer(轻扫) 方向,如果想要两个方向支持,添加两个轻扫手势 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; //1.创建手势对象 UISwipeGestureRecognizer *swipe = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(swipeGesture:)]; UISwipeGestureRecognizer *swipe1= [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(swipeGesture:)]; //轻扫是有方向的 swipe1.direction = UISwipeGestureRecognizerDirectionLeft; //2.添加到需要使用收拾的对象上 [self.imageView addGestureRecognizer:swipe]; [self.imageView addGestureRecognizer:swipe1];&#125; //3.实现收拾的操作（这个手势怎么用）-(void)swipeGesture:(UISwipeGestureRecognizer *)sender&#123; if(sender.direction == UISwipeGestureRecognizerDirectionLeft) &#123; NSLog(@"1"); &#125; if(sender.direction == UISwipeGestureRecognizerDirectionRight) &#123; NSLog(@"2"); &#125;&#125; ##手势识别-UIRotationGestureRecognizer(旋转) rotation 1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; //1.创建手势对象 UIRotationGestureRecognizer *rotate = [[UIRotationGestureRecognizer alloc]initWithTarget:self action:@selector(rotateGesture:)]; //2.添加到需要使用收拾的对象上 [self.imageView addGestureRecognizer:rotate];&#125; //3.实现收拾的操作（这个手势怎么用）-(void)rotateGesture:(UIRotationGestureRecognizer *)sender&#123; // self.imageView.transform = CGAffineTransformMakeRotation(sender.rotation); // //二次旋转的时候会从水平位置开始，放弃这种做法 //每次都计算的是偏移量，并不是用sender.rotation直接进行旋转，因为每次旋转的时候都会从零开始，并不是从上一次的位置继续旋转。 self.imageView.transform = CGAffineTransformRotate(self.imageView.transform,sender.rotation); sender.rotation = 0;&#125; ##12-手势识别-UIPinchGestureRecognizer(缩放) scale 1234567891011121314151617181920- (void)viewDidLoad &#123; [super viewDidLoad]; //1.创建手势对象 UIPinchGestureRecognizer * pinch = [[UIPinchGestureRecognizer alloc]initWithTarget:self action:@selector(pinchGesture:)]; //2.添加到需要使用收拾的对象上 [self.imageView addGestureRecognizer:pinch];&#125; //3.实现收拾的操作（这个手势怎么用）-(void)pinchGesture:(UIPinchGestureRecognizer *)sender&#123; self.imageView.transform = CGAffineTransformScale(self.imageView.transform, sender.scale, sender.scale); sender.scale = 1;&#125; ##13-手势识别-UIPanGestureRecognizer(平移) translation 12345678910111213141516171819202122232425- (void)viewDidLoad &#123; [super viewDidLoad]; //1.创建手势对象 UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(panGesture:)]; //2.添加到需要使用收拾的对象上 [self.imageView addGestureRecognizer:pan];&#125; //3.实现收拾的操作（这个手势怎么用）-(void)panGesture:(UIPanGestureRecognizer *)sender&#123; CGPoint p = [sender translationInView:sender.view];// self.imageView.center = CGPointMake(self.imageView.center.x+p.x, self.imageView.center.y+p.y); self.imageView.transform = CGAffineTransformTranslate(self.imageView.transform, p.x, p.y); //恢复到初始结果 [sender setTranslation:CGPointZero inView:sender.view];&#125; ##14-手势冲突 关于手势 手势基于触摸事件 六种 使用过程,三部 1.创建手势对象(做什么手势) 2.添加到需要使用手势的对象上(在哪使用手势) 3.实现手势执行的方法 (手势怎么执行) 注意:旋转,缩放,平移,需要有个一个’恢复初始状态’的操作,transform改变的时候不用make 手势冲突: 代理解决,找最长的方法,bool类型的返回值,返回yes即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import "ViewController.h"@interface ViewController () &lt;UIGestureRecognizerDelegate&gt;@property (weak, nonatomic) IBOutlet UIImageView *imageView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 1.创建手势对象(用什么手势) UIRotationGestureRecognizer* rotate = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(rotateGesture:)]; // 2.添加到需要使用手势的对象上(谁用这个手势) [self.imageView addGestureRecognizer:rotate]; // 1.创建手势对象(用什么手势) UIPinchGestureRecognizer* pinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinchGesture:)]; pinch.delegate = self; // 2.添加到需要使用手势的对象上(谁用这个手势) [self.imageView addGestureRecognizer:pinch];&#125;// 3.实现手势的操作(这个手势怎么用)- (void)rotateGesture:(UIRotationGestureRecognizer*)sender&#123; NSLog(@"%f", sender.rotation); // self.imageView.transform = CGAffineTransformMakeRotation(sender.rotation); self.imageView.transform = CGAffineTransformRotate(self.imageView.transform, sender.rotation); // sender.rotation = 0;&#125;// 3.实现手势的操作(这个手势怎么用)- (void)pinchGesture:(UIPinchGestureRecognizer*)sender&#123; self.imageView.transform = CGAffineTransformScale(self.imageView.transform, sender.scale, sender.scale); sender.scale = 1; // NSLog(@"%f",sender.scale);&#125;- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; return YES;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS中三大类事件]]></title>
      <url>%2F2014%2F10%2F24%2FiOS%E4%B8%AD%E4%B8%89%E5%A4%A7%E7%B1%BB%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[触摸事件/NSSet1234567891011121314151617181920212223// 开始的时候,手指摸到这个对象的时候- (void)touchesBegan:(NSSet&lt;UITouch*&gt;*)touches withEvent:(UIEvent*)event&#123; NSLog(@&quot;%s&quot;, __func__);&#125;// 移动的时候,手指在这个对象上移动- (void)touchesMoved:(NSSet&lt;UITouch*&gt;*)touches withEvent:(UIEvent*)event&#123; NSLog(@&quot;%s&quot;, __func__);&#125;// 结束的时候,手指在这个对象上离开- (void)touchesEnded:(NSSet&lt;UITouch*&gt;*)touches withEvent:(UIEvent*)event&#123; NSLog(@&quot;%s&quot;, __func__);&#125;// 取消,来电话的时候回取消触摸事件- (void)touchesCancelled:(NSSet&lt;UITouch*&gt;*)touches withEvent:(UIEvent*)event&#123; NSLog(@&quot;%s&quot;, __func__);&#125; NSSet 集合 无序 不重复 取值方法:随便一个(anyObject) 遍历方法:forin 关于set 1234567891011121314151617181920212223 NSSet* set = [NSSet setWithObjects:@&quot;1&quot;, @&quot;222&quot;, @10, @&quot;hello&quot;, @&quot;222&quot;, nil]; // anyobject 会取一个当前集合 &apos;方便&apos; 的元素 不保证是随机的 NSLog(@&quot;%@&quot;, set.anyObject);``` ## 单点触摸案例```objc//开始点击- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; //获取触摸对象 UITouch *t = [touches anyObject]; //手指的位置 //inView 的 view 参数 表示，以xxxxx的坐标系的位置为原点 CGPoint p = [t locationInView:self.superview]; //修改center self.center = p ;&#125; 12345678910111213141516-(void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; //获取触摸对象 UITouch *t = [touches anyObject]; //手指的位置 //inView 的 view 参数 表示，以xxxxx的坐标系的位置为原点 CGPoint p = [t locationInView:self];//self.superview也可以用 CGPoint pLast = [t previousLocationInView:self]; CGFloat offsetX = p.x - pLast.x; CGFloat offsetY = p.y - pLast.y; //修改center self.center = CGPointMake(self.center.x + offsetX, self.center.y + offsetY);&#125; 多点触摸案例触摸点是随机的,sb中要开启多点模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import "WHDemoView.h"@interface WHDemoView ()@property(nonatomic,strong)NSArray *array;@end@implementation WHDemoView-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; self.array = @[@"spark_blue",@"spark_red"]; [self addSpark:touches];&#125;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self addSpark:touches];&#125;-(void)addSpark:(NSSet&lt;UITouch *&gt; *)touches&#123; int i = 0; for (UITouch * t in touches) &#123;//t是随机的// //获取出没对象// UITouch * t = touches.anyObject; //获取手指的位置 CGPoint p =[t locationInView:self]; //imageView UIImageView * imageView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:self.array[i]]]; imageView.center = p; [self addSubview:imageView]; [UIView animateWithDuration:2 animations:^&#123; imageView.alpha = 0; &#125; completion:^(BOOL finished) &#123; [imageView removeFromSuperview]; &#125;]; i++; &#125;&#125;@end 思维导图及示例demo下载思维导图示例demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[控件不能响应的情况]]></title>
      <url>%2F2014%2F10%2F22%2F%E6%8E%A7%E4%BB%B6%E4%B8%8D%E8%83%BD%E5%93%8D%E5%BA%94%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
      <content type="text"><![CDATA[##控件不能响应的情况 控件隐藏的时候 控件透明度小于等于0.01的时候 当用户交互关闭的时候 子控件超出父控件的有效范围 ##事件的产生和传递 寻找的过程 先看是不是允许用户交互 看手指的位置 是否在自己的范围内 倒着往前遍历自己的子控件 执行hitTest 如果子控件有, 直接返回,如果没有,直接返回自己(表示,没有比自己再合适不过处理这个事件的了) 响应者链条: 能够响应事件的一串响应者对象 从下往上通过hitTest找, 从上往下通过touchBegan传递事件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内存警告方法]]></title>
      <url>%2F2014%2F04%2F22%2F3.%E5%86%85%E5%AD%98%E8%AD%A6%E5%91%8A%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[内存警告方法1234567891011121314151617- (void)didReceiveMemoryWarning&#123; [super didReceiveMemoryWarning]; // Called when the parent application receives a memory warning. // 这个方法在应用程序接受到内存警告的时候调用 // On iOS 6.0 it will no longer clear the view by default. // 在6.0只有 不再默认清理 self.view // 当这个view是否正在显示 // 这个view是否已经被加载 if (self.isViewLoaded &amp;&amp; self.view.window == nil) &#123; [self setView:nil]; &#125; // 处理当前控制器强引用的属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[控制器与视图的生命周期]]></title>
      <url>%2F2014%2F04%2F19%2F2.%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E8%A7%86%E5%9B%BE%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[控制器在导航控制器的生命周期1234567891011121314// 控制器在nav中 push的时候 的过程// one 将要消失// two view加载完成// two 将要显示// one 已经消失// two 已经显示// 控制器在nav中 拖拽返回的时候// 拖拽的时候 two 将要消失 one 将要显示// 松手返回到上一个页面 two 已经消失 one 已经显示// 控制器在nav中 拖拽返回的时候// 拖拽的时候 two 将要消失 one 将要显示// 松手没有返回上一个页面 one 将要消失 one 已经消失 two 将要显示 two 已经显示 控制器在标签控制器的生命周期123456// 控制器在tabbarController中的声明周期// two view加载完成// two view将要显示// one view将要消失// one view已经消失// two view已经显示 控制器在nav的生命周期 控制器在nav中push的时候的过程// one 将要消失// two view加载完成// two 将要显示// one 已经消失// two 已经显示 控制器在nav中 拖拽返回的时候// 拖拽的时候 two 将要消失 one 将要显示// 松手返回到上一个页面 two 已经消失 one 已经显示 控制器在nav中 拖拽返回的时候// 拖拽的时候 two 将要消失 one 将要显示// 松手没有返回上一个页面 one 将要消失 one 已经消失 two 将要显示 two 已经显示 视图的生命周期方法123456789101112131415161718192021222324252627282930313233343536#import "DemoView.h"@implementation DemoView// 将要移动到superView 通过'addSubView'- (void)willMoveToSuperview:(nullable UIView*)newSuperview&#123; [super willMoveToSuperview:newSuperview]; NSLog(@"%@ -- %s", self.class, __FUNCTION__);&#125;// 已经移动到superView- (void)didMoveToSuperview&#123; [super didMoveToSuperview]; NSLog(@"%@ -- %s", self.class, __FUNCTION__);&#125;// 将要移动到window '显示/消失'- (void)willMoveToWindow:(nullable UIWindow*)newWindow&#123; [super willMoveToWindow:newWindow]; NSLog(@"%@ -- %s", self.class, __FUNCTION__); NSLog(@"willMoveToWindow ------- &gt; %@", newWindow);&#125;// 已经移动到window '显示/消失'- (void)didMoveToWindow&#123; [super didMoveToWindow]; NSLog(@"%@ -- %s", self.class, __FUNCTION__);&#125;@end 输出结果： 123456782016-07-09 13:17:27.255 05-控制器生命周期[31547:3527271] OneViewController -- -[ViewController viewDidLoad]2016-07-09 13:17:27.256 05-控制器生命周期[31547:3527271] DemoView -- -[DemoView willMoveToSuperview:]2016-07-09 13:17:27.256 05-控制器生命周期[31547:3527271] DemoView -- -[DemoView didMoveToSuperview]2016-07-09 13:17:27.258 05-控制器生命周期[31547:3527271] OneViewController -- -[ViewController viewWillAppear:]2016-07-09 13:17:27.258 05-控制器生命周期[31547:3527271] DemoView -- -[DemoView willMoveToWindow:]2016-07-09 13:17:27.258 05-控制器生命周期[31547:3527271] willMoveToWindow ------- &gt; &lt;UIWindow: 0x7f8d88cbd2d0; frame = (0 0; 375 667); gestureRecognizers = &lt;NSArray: 0x7f8d88cbe4d0&gt;; layer = &lt;UIWindowLayer: 0x7f8d88cb1fc0&gt;&gt;2016-07-09 13:17:27.259 05-控制器生命周期[31547:3527271] DemoView -- -[DemoView didMoveToWindow]2016-07-09 13:17:27.266 05-控制器生命周期[31547:3527271] OneViewController -- -[ViewController viewDidAppear:] 如何判断一个view是否显示在屏幕上,如果这个view的.window属性,有值,证明他已经显示在当前的屏幕上,如果没有值的话,表示当前没有显示在屏幕上 addSubView 会触发’willMoveToSuperview’’didMoveToSuperview’的方法 这四个方法显示和消失的时候都会调用,只不过是移动到不同的view和不同window 整体思维导图 高清思维导图下载地址绘图.png MindNode源文件下载地址绘图.mindnode 反馈与建议 微博：@whong77 邮箱：&#119;&#104;&#111;&#x6e;&#x67;&#x37;&#x39;&#x31;&#x31;&#50;&#48;&#55;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#109;]]></content>
    </entry>

    
  
  
</search>
